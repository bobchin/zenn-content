---
title: "RaspberryPi Pico"
emoji: "ğŸ’¨"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["RaspberryPi", "Pico", "PIO"]
published: false
---

## Links

### Pico

Raspberry Pi Pico Home
https://www.raspberrypi.com/products/raspberry-pi-pico-2/
https://www.raspberrypi.com/products/raspberry-pi-pico

Raspberry Pi Pico ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã‚ˆã†
https://datasheets.raspberrypi.com/pico/getting-started-with-pico-JP.pdf

RP2040 ã‚’ä½¿ç”¨ã—ãŸãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢è¨­è¨ˆ
https://datasheets.raspberrypi.com/rp2040/hardware-design-with-rp2040-JP.pdf

#### MicroPython

GetStart MicroPython
https://www.raspberrypi.com/documentation/microcontrollers/micropython.html

python-sdk
https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-python-sdk.pdf

MicroPython
https://micropython.org/

### ãƒ”ãƒ³ã‚¢ã‚µã‚¤ãƒ³

Pico, Pico2
https://datasheets.raspberrypi.com/pico/Pico-2-Pinout.pdf

| No  | GPNo | Func1    | Func2    | Func3    |
| :-: | :--- | :------- | :------- | :------- |
|  1  | GP0  | UART0 TX | I2C0 SDA | SPI0 RX  |
|  2  | GP1  | UART0 RX | I2C0 SCL | SPI0 CSn |
|  3  | GND  |          |          |          |
|  4  | GP2  |          | I2C1 SDA | SPI0 SCK |
|  5  | GP3  |          | I2C1 SCL | SPI0 TX  |
|  6  | GP4  | UART1 TX | I2C0 SDA | SPI0 RX  |
|  7  | GP5  | UART1 RX | I2C0 SCL | SPI0 CSn |
|  8  | GND  |          |          |          |
|  9  | GP6  |          | I2C1 SDA | SPI0 SCK |
| 10  | GP7  |          | I2C1 SCL | SPI0 TX  |
| --- | ---- | -------- | -------- | -------- |
| 11  | GP8  | UART1 TX | I2C0 SDA | SPI1 RX  |
| 12  | GP9  | UART1 RX | I2C0 SCL | SPI1 CSn |
| 13  | GND  |          |          |          |
| 14  | GP10 |          | I2C1 SDA | SPI1 SCK |
| 15  | GP11 |          | I2C1 SCL | SPI1 TX  |
| 16  | GP12 | UART0 TX | I2C0 SDA | SPI1 RX  |
| 17  | GP13 | UART0 RX | I2C0 SCL | SPI1 Csn |
| 18  | GND  |          |          |          |
| 19  | GP14 |          | I2C1 SDA | SPI1 SCK |
| 20  | GP15 |          | I2C1 SCL | SPI1 TX  |

| No  | GPNo       | Func1    | Func2    | Func3    |
| :-: | :--------- | :------- | :------- | :------- |
| 21  | GP16       | UART0 RX | I2C0 SDA | SPI0 RX  |
| 22  | GP17       | UART0 TX | I2C0 SCL | SPI0 CSn |
| 23  | GND        |          |          |          |
| 24  | GP18       |          | I2C1 SDA | SPI0 SCK |
| 25  | GP19       |          | I2C1 SCL | SPI0 TX  |
| 26  | GP20       |          | I2C0 SDA |          |
| 27  | GP21       |          | I2C0 SCL |          |
| 28  | GND        |          |          |          |
| 29  | GP22       |          |          |          |
| 30  | RUN        |          |          |          |
| --- | ---------- | -------- | -------- | -------- |
| 31  | GP26       |          | I2C1 SDA | ADC0     |
| 32  | GP27       |          | I2C1 SCL | ADC1     |
| 33  | GND        |          |          | AGND     |
| 34  | GP28       |          |          | ADC2     |
| 35  |            |          |          | ADC VREF |
| 36  | 3V3<br>OUT |          |          |          |
| 37  | 3V3<br>EN  |          |          |          |
| 38  | GND        |          |          |          |
| 39  | VSYS       |          |          |          |
| 40  | VBUS       |          |          |          |

## PIO

https://karakuri-musha.com/inside-technology/arduino-raspberrypi-picow-tips-piostartup01/

- [Interface 2021 å¹´ 8 æœˆå·](https://interface.cqpub.co.jp/magazine/202108/)
- [ãƒ©ã‚ºãƒ”ã‚³ PIO ï½è§£èª¬ç·¨ï½](https://moons.link/pico/post-498/)
- [Raspberry Pi Pico ã®Programmable I/O (PIO)å…¥é–€](https://qiita.com/fude-t/items/d2baf1c98ba807273dcf)
- [åˆã‚ã®ä¸€æ­©ï¼ãƒ©ã‚ºãƒ‘ã‚¤ Pico ãƒã‚¤ã‚³ãƒ³ Ã—Python ã§ L ãƒã‚«å…¥é–€](https://www.zep.co.jp/utaguchi/article/z-picoled_all-da1/)
- [Raspberry Pi Pico/W ã®PIOã‚’èª¿æŸ»ã™ã‚‹ãï¼ï¼ˆPIO : Programmable I/Oï¼‰](https://karakuri-musha.com/inside-technology/arduino-raspberrypi-picow-tips-piostartup01/)

### MicroPython ãƒ—ãƒ­ã‚°ãƒ©ãƒ 

```python:æœ€å°é™ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ 
from machine import Pin
import rp2
import time

@rp2.asm_pio(set_init=rp2.PIO.OUT_LOW)
def blink_led():
  set(pins, 1)
  set(pins, 0)

led_pin = Pin("LED", Pin.OUT)
sm = rp2.StateMachine(0, blink_led, set_base=led_pin, freq=2000)

sm.active(1)
time.sleep(5)
sm.active(0)
```

- `@rp2.asm_pio`
  å‡¦ç†ã‚’è¨˜è¿°ã™ã‚‹é–¢æ•°ã«ä»˜ã‘ã‚‹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã§ã€åˆæœŸå€¤ãªã©ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã®ã«ä½¿ç”¨ã™ã‚‹ã€‚
  [PIO é–¢é€£é–¢æ•°](https://micropython-docs-ja.readthedocs.io/ja/latest/library/rp2.html)

  - GPIO ãƒ”ãƒ³ã®åˆæœŸçŠ¶æ…‹ã‚’æŒ‡å®š(PIO.IN_LOW | PIO.IN_HIGH | PIO.OUT_LOW | PIO.OUT_HIGH)
    è¤‡æ•°ã®ãƒ”ãƒ³ã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯ã‚¿ãƒ—ãƒ«ã§æŒ‡å®šã™ã‚‹ ex) out_init=(PIO.OUT_LOW, PIO.OUT_LOW)
    ãƒ”ãƒ³ã®å…ˆé ­ã¯ `rp2.StateMachine` ã§æŒ‡å®šã™ã‚‹
    - out_init=None
    - set_init=None
    - sideset_init=None
      - side_pindir=False â€» True ã‚’æŒ‡å®šã™ã‚‹ã¨ãƒ”ãƒ³ã®æ–¹å‘ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã«æ³¨æ„

  - ã‚·ãƒ•ãƒˆã™ã‚‹æ–¹å‘ã‚’æŒ‡å®š(PIO.SHIFT_LEFT | PIO.SHIFT_RIGHT)
    PIO.SHIFT_RIGHT = MSB -> LSB ã®æ–¹å‘ã«ã‚·ãƒ•ãƒˆ = MSB ã‹ã‚‰1ãƒ“ãƒƒãƒˆãšã¤
    PIO.SHIFT_LEFT  = MSB <- LSB ã®æ–¹å‘ã«ã‚·ãƒ•ãƒˆ = LSB ã‹ã‚‰1ãƒ“ãƒƒãƒˆãšã¤
    - in_shiftdir=PIO.SHIFT_LEFT
    - out_shiftdir=PIO.SHIFT_LEFT

  - auto ç™ºå‹•ã®ã—ãã„å€¤ï¼ˆãƒ“ãƒƒãƒˆæ•°ï¼‰
    - push_thresh=32
    - pull_thresh=32

  - æ©Ÿèƒ½ã®æœ‰åŠ¹åŒ–
    - autopush=False
    - autopull=False

  - 8 ã¤ã® FIFO ã® TX ã¨ RX ã¸ã®å‰²ã‚Šå½“ã¦(PIO.JOIN_NONE(TX=4, RX=4) | PIO.JOIN_TX(TX=8, RX=0) | PIO.JOIN_RX(TX=0, RX=8))
    - fifo_join=PIO.JOIN_NONE

- `def xxx():`
  å‡¦ç†ã®å†…å®¹ã‚’ã‚¢ã‚»ãƒ³ãƒ–ãƒªè¨€èªã§è¨˜è¿°ã™ã‚‹

  - åŸºæœ¬å‘½ä»¤
    - jmp() : ãƒ©ãƒ™ãƒ«ã«ã‚¸ãƒ£ãƒ³ãƒ—ã™ã‚‹
    - wait(): æŒ‡å®šã—ãŸãƒ”ãƒ³ãŒæŒ‡å®šã—ãŸå€¤(high | low)ã«ãªã‚‹ã¾ã§å¾…ã¤
    - in_() : ISR(ã‚·ãƒ•ãƒˆãƒ¬ã‚¸ã‚¹ã‚¿) ã«å€¤ã‚’ã‚·ãƒ•ãƒˆã™ã‚‹
    - out() : OSR(ã‚·ãƒ•ãƒˆãƒ¬ã‚¸ã‚¹ã‚¿) ã‹ã‚‰å€¤ã‚’ã‚·ãƒ•ãƒˆã™ã‚‹
    - push(): ISR(ã‚·ãƒ•ãƒˆãƒ¬ã‚¸ã‚¹ã‚¿) ã‹ã‚‰RX FIFO ã«ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ—ãƒƒã‚·ãƒ¥
    - pull(): TX FIFO ã‹ã‚‰ OSR(ã‚·ãƒ•ãƒˆãƒ¬ã‚¸ã‚¹ã‚¿) ã«ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ—ãƒ«
    - mov() : å€¤ã‚’ç§»å‹•ã™ã‚‹
    - irq() : IRQ ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
    - set() : å€¤ã‚’æŒ‡å®šã—ãŸå ´æ‰€ã«ã‚»ãƒƒãƒˆ
  - ä¿®é£¾å­
    - .side()
    - .delay()
    - [value] = .delay(value)
  - ãã®ä»–
    - nop()
    - warp_target(): ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æŠ˜ã‚Šè¿”ã—å¾Œã«å®Ÿè¡Œã‚’ç¶™ç¶šã™ã‚‹ä½ç½®ã‚’æŒ‡å®š
    - wrap()       : ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®çµ‚ç«¯ã¨æŠ˜ã‚Šè¿”ã—ã®ä½ç½®ã‚’æŒ‡å®š
    - label()      : jmp() ç”¨ã®ãƒ©ãƒ™ãƒ«ã‚’ã¤ã‘ã‚‹
    - word()

- `sm = rp2.StateMachine`
  ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã€‚
  PIO 1 ã¤ã«ã¤ãã€ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ãŒ 4 å€‹å…¥ã£ã¦ãŠã‚Šã€PIO ã¯ 2å€‹ã‚ã‚‹ã€‚è¨ˆ 8 å€‹ã®ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ãŒå­˜åœ¨ã€‚0ï½7 ã§æŒ‡å®šã€‚
  [PIOã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹](https://micropython-docs-ja.readthedocs.io/ja/latest/library/rp2.StateMachine.html)

  - id:
    -  0ï½3: PIO1å€‹ç›®
    -  4ï½7: PIO2å€‹ç›®
 - program: å‡¦ç†å†…å®¹ã‚’è¨˜è¿°ã—ãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒ‡å®š
 - freq=-1: å®Ÿè¡Œå‘¨æ³¢æ•°(Hz) ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯125MHz
 - ä½¿ç”¨ã™ã‚‹å…ˆé ­ãƒ”ãƒ³ã®æŒ‡å®š
   - in_base=None : in() ã§ä½¿ç”¨
   - out_base=None: out() ã§ä½¿ç”¨
   - set_base=None: set() ã§ä½¿ç”¨
   - jmp_pin=None : jmp() ã§ä½¿ç”¨
   - sideset_base=None: sideset ã§ä½¿ç”¨
 - ã‚·ãƒ•ãƒˆã™ã‚‹æ–¹å‘ã‚’æŒ‡å®š(PIO.SHIFT_LEFT | PIO.SHIFT_RIGHT)
   - in_shiftdir=None : @rp2.asm_pio ã¨åŒã˜ã€‚ä¸Šæ›¸ãã§ãã‚‹ã€‚
   - out_shiftdir=None: @rp2.asm_pio ã¨åŒã˜ã€‚ä¸Šæ›¸ãã§ãã‚‹ã€‚
 - auto ç™ºå‹•ã®ã—ãã„å€¤ï¼ˆãƒ“ãƒƒãƒˆæ•°ï¼‰
   - push_thresh=None : @rp2.asm_pio ã¨åŒã˜ã€‚ä¸Šæ›¸ãã§ãã‚‹ã€‚
   - pull_thresh=None : @rp2.asm_pio ã¨åŒã˜ã€‚ä¸Šæ›¸ãã§ãã‚‹ã€‚auto ç™ºå‹•ã®ã—ãã„å€¤ï¼ˆãƒ“ãƒƒãƒˆæ•°ï¼‰


- `sm.active(1)`
  ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã®å®Ÿè¡Œé–‹å§‹

#### [ã‚µãƒ³ãƒ—ãƒ«](https://github.com/raspberrypi/pico-micropython-examples/blob/master/pio)

```python:blink.py
from machine import Pin
import rp2
import time

# LED ã‚’ãƒã‚«ãƒã‚«ã•ã›ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ 

# set å‘½ä»¤ã«ï¼‘ã¤ã® GPIO ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã¦ã€å‡ºåŠ›ãƒ”ãƒ³ã¨ãªã£ã¦ã„ã‚‹ã€‚
# ãŸãã•ã‚“ã®ãƒ‡ã‚£ãƒ¬ã‚¤ã‚’ä½¿ã£ã¦ã€äººé–“ã®ç›®ã«ç‚¹æ»…ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«ã—ã¦ã„ã‚‹ã€‚
# setå‘½ä»¤å«ã‚ã¦ 32 * 5 = 160 ã‚µã‚¤ã‚¯ãƒ«ãªã®ã§ã€160(times) * 0.5m(sec/times) = 80m(sec)
@rp2.asm_pio(set_init=rp2.PIO.OUT_LOW)  # åˆæœŸå€¤ã¯ LOW
def blink():
    wrap_target()       # ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æŠ˜ã‚Šè¿”ã—ä½ç½®
    set(pins, 1)   [31] # set_baseã§å‰²ã‚Šå½“ã¦ã¦ã„ã‚‹ãƒ”ãƒ³ã‚’HIGHã«ã—ã¦ã€31ã‚µã‚¤ã‚¯ãƒ«ãƒ‡ã‚£ãƒ¬ã‚¤ã™ã‚‹
    nop()          [31] # ä½•ã‚‚ã—ãªã„å‘½ä»¤ 1ã‚µã‚¤ã‚¯ãƒ« + 31 ãƒ‡ã‚£ãƒ¬ã‚¤ = 32ã‚µã‚¤ã‚¯ãƒ«ãƒ‡ã‚£ãƒ¬ã‚¤
    nop()          [31]
    nop()          [31]
    nop()          [31]
    set(pins, 0)   [31] # set_baseã§å‰²ã‚Šå½“ã¦ã¦ã„ã‚‹ãƒ”ãƒ³ã‚’LOWã«ã—ã¦ã€31ã‚µã‚¤ã‚¯ãƒ«ãƒ‡ã‚£ãƒ¬ã‚¤ã™ã‚‹
    nop()          [31]
    nop()          [31]
    nop()          [31]
    nop()          [31]
    wrap()              # ã“ã“ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æŠ˜ã‚Šè¿”ã™

# ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
# blink() ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€2000Hzã§å®Ÿè¡Œã€‚seté–¢æ•°ç”¨ã«LEDãƒ”ãƒ³ã‚’æŒ‡å®šã—ã¦ã„ã‚‹ã€‚
# 2000Hz = 1(sec) / 2000(times) = 0.5m sec/times = 1ã‚µã‚¤ã‚¯ãƒ«ã®æ™‚é–“
sm = rp2.StateMachine(0, blink, freq=2000, set_base=Pin(25))

# 3ç§’é–“ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹
sm.active(1)
time.sleep(3)
sm.active(0)
```

```python:1hz.py
from machine import Pin
import rp2
import time

# LED ã‚’ãƒã‚«ãƒã‚«ã•ã›ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ 

@rp2.asm_pio(set_init=rp2.PIO.OUT_LOW)
def blink_1hz():
  # cycles = 1 + 1 + (1+5) + (30+1)*32 = 1000
  # LED ãƒ”ãƒ³ã‚’ HIGH ã«ã—ã¦ã€1000ã‚µã‚¤ã‚¯ãƒ« = 0.5sec
  irq(rel(0))                   # 1
  set(pins, 1)                  # 1
  set(x, 31)               [5]  # 6
  label("delay_high")
  nop()                    [29] # 30
  jmp(x_dec, "delay_high")      # 1  x ãŒ 0 ã«ãªã‚‹ã¾ã§ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆ32å›ç¹°ã‚Šè¿”ã™ï¼‰

  # cycles = 1 + (1+6) + (30+1)*32 = 1000
  # LED ãƒ”ãƒ³ã‚’ LOW ã«ã—ã¦ã€1000ã‚µã‚¤ã‚¯ãƒ« = 0.5sec
  set(pins, 0)                  # 1
  set(x, 31)               [6]  # 7
  label("delay_high")
  nop()                    [29] # 30
  jmp(x_dec, "delay_high")      # 1  x ãŒ 0 ã«ãªã‚‹ã¾ã§ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆ32å›ç¹°ã‚Šè¿”ã™ï¼‰

sm = rp2.StateMachine(0, blink_1hz, freq=2000, set_base=Pin("LED", Pin.OUT))
sm.irq(lambda p: print(time.ticks_ms()))
sm.active(1)
```

```python:exec.py
from machine import Pin
import rp2
import time

# StateMachine.exec() ã‚’ä½¿ã£ãŸå‘½ä»¤ã®å®Ÿè¡Œ

@rp2.asm_pio(set_init=rp2.PIO.OUT_LOW)
def prog():
  pass

sm = rp2.StateMachine(0, prog, set_base=Pin("LED"))

sm.exec("set(pins, 1)")
time.sleep(0.5)
sm.exec("set(pins, 0)")

set_H = rp2.asm_pio_encode("set(pins, 1)", 0)
set_L = rp2.asm_pio_encode("set(pins, 0)", 0)
sm.exec(set_H)
time.sleep(0.5)
sm.exec(set_L)
```

```python:irq.py
import time
import rp2

# irq ã®ã‚µãƒ³ãƒ—ãƒ«
# ã²ã¨ã¤ã® PIO ã¯ 0ï½7 ã®å‰²ã‚Šè¾¼ã¿ãƒ•ãƒ©ã‚°ãŒã‚ã‚Šã€å„ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã§å…±æœ‰ã—ã¦ã„ã‚‹ã€‚
# 0ï½3: ã‚·ã‚¹ãƒ†ãƒ ãƒ¬ãƒ™ãƒ«å‰²è¾¼
# 4ï½7: ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³å†…å‰²è¾¼

@rp2.asm_pio()
def irq_test():
  wrap_target()
  nop()   [31]  # 32*4 = 128 ã‚µã‚¤ã‚¯ãƒ«
  nop()   [31]
  nop()   [31]
  nop()   [31]
  irq(0)
  nop()   [31]  # 32*4 = 128 ã‚µã‚¤ã‚¯ãƒ«
  nop()   [31]
  nop()   [31]
  nop()   [31]
  irq(1)
  wrap()

rp2.PIO(0).irq(lambda pio: print(pio.irq().flags()))

sm = rp2.StateMachine(0, irq_test, freq=2000)
sm.active(1)
time.sleep(1)
sm.active(0)
```

```python:pinchange.py
from machine import Pin
import rp2
import time

# ãƒ”ãƒ³ã®çŠ¶æ…‹ãŒ LOW ã«ãªã‚‹ã¾ã§ã‚¦ã‚§ã‚¤ãƒˆã—ã€å‰²ã‚Šè¾¼ã¿ã‚’ç™ºç”Ÿã™ã‚‹

@rp2.asm_pio()
def wait_pin_low():
  wrap_target()
  wait(0, pin, 0)     # in_base ã§æŒ‡å®šã•ã‚ŒãŸãƒ”ãƒ³ãŒ LOW ã«ãªã‚‹ã¾ã§å¾…ã¤
  irq(block, rel(0))  # å‰²ã‚Šè¾¼ã¿ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆã€‚ç›¸å¯¾çš„ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®š
  wait(1, pin, 0)     # in_base ã§æŒ‡å®šã•ã‚ŒãŸãƒ”ãƒ³ãŒ HIGH ã«ãªã‚‹ã¾ã§å¾…ã¤
  wrap()

def handler(sm):
  print(time.ticks_ms(), sm)

pin16 = Pin(16, Pin.IN, Pin.PULL_UP)
sm0 = rp2.StateMachine(0, wait_pin_low, in_base=pin16)
sm0.irq(handler)

pin17 = Pin(17, Pin.IN, Pin.PULL_UP)
sm1 = rp2.StateMachine(1, wait_pin_low, in_base=pin17)
sm0.irq(handler)

sm0.active(1)
sm1.active(1)
```

#### NeoPixel(WS2812)

- ãƒ”ãƒ³
  - 3.3V
  - GND
  - Data

- ãƒ‡ãƒ¼ã‚¿
  - 1bit
    - 0: T0H(0.4us $\pm$150ns) + T0L(0.85us $\pm$150ns) = 1.25us $\pm$600ns
    - 1: T1H(0.8us $\pm$150ns) + T1L(0.45us $\pm$150ns) = 1.25us $\pm$600ns
    - ãƒªã‚»ãƒƒãƒˆ: 50usä»¥ä¸Šã®Low
  - è‰²(24bit)
    -  0ï½7 : G
    -  8ï½15: R
    - 16ï½23: B

- value0

```mermaid:value0
sequenceDiagram
  Low-->>High: 
  High-->>Low: 220ns ~ 380ns
  Low-->>High: 580ns ~ 1000ns
```

- value1

```mermaid:value1
sequenceDiagram
  Low-->>High: 
  High-->>Low: 580ns ~ 1000ns
  Low-->>High: 580ns ~ 1000ns
```

- æ™‚é–“
  - æ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³
    - T1: 300ns(0 ã®Highã®æ™‚é–“)
    - T2: 700ns(1 ã®Highã®æ™‚é–“)
    - T3: 700ns(0,1 å…±é€šã®Lowã®æ™‚é–“)

  - å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³
    - T1: 0.25ns(0,1 å…±é€šã®Highã®æ™‚é–“)
    - T2: 0.625ns(0 ã¯Low, 1 ã¯ High)
    - T3: 0.375ns(0,1 å…±é€šã®Lowã®æ™‚é–“)
      - 0 => High=T1,    Low=T2+T3
      - 1 => High=T1+T2, Low=T3

```python:ws2812.py
import array, time
from machine import Pin
import rp2

# WS2812 LED ã®å€‹æ•°
NUM_LEDS = 8

# 24ãƒ“ãƒƒãƒˆæ¯ã«è‡ªå‹•ã§MSBã‹ã‚‰å‡ºåŠ›ã—ã¦ã„ã
@rp2.asm_pio(sideset_init=rp2.PIO.OUT_LOW, out_shiftdir=rp2.PIO.SHIFT_LEFT, autopull=True, pull_thresh=24)
def ws2812():
  # 1bit ã®å‡¦ç†ã‚’è¨˜è¿°
  T1 = 2
  T2 = 5
  T3 = 3
  wrap_target()
  label("bitloop")
  out(x, 1)               .side(0)    [T3 - 1]  # T3=3ã‚µã‚¤ã‚¯ãƒ«å¾…ã¤
  jmp(not_x, "do_zero")   .side(1)    [T1 - 1]  # T1=2ã‚µã‚¤ã‚¯ãƒ«å¾…ã¤
  jmp("bitloop")          .side(1)    [T2 - 1]  # T2=5ã‚µã‚¤ã‚¯ãƒ«å¾…ã¤
  label("do_zero")
  nop()                   .side(0)    [T2 - 1]  # T2=5ã‚µã‚¤ã‚¯ãƒ«å¾…ã¤
  wrap()

# PIOã‚’ä½¿ç”¨ã—ãªã„å ´åˆã¯ã€machine.bitstrem() ãŒä½¿ç”¨ã§ãã‚‹
# https://micropython-docs-ja.readthedocs.io/ja/latest/library/machine.html#machine.bitstream
# timing = (400, 850, 800, 450) # high_time0, low_time0, high_time1, low_time1 ã®å„ãƒŠãƒç§’
# machine.bitstream(Pin(22), 0, timing, buf)


# Pin(22) ã«å‡ºåŠ›
# å‘¨æ³¢æ•° 8MHz = 0.125nsec
sm = rp2.StateMachine(0, ws2812, freq=8_000_000, sideset_base=Pin(22))
sm.active(1)

# LED RGBå€¤ã®é…åˆ—ã‚’ä½¿ã£ã¦LEDã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¡¨ç¤º
ar = array.array("I", [0 for _ in range(NUM_LEDS)])

# è‰²ã‚’ç¹°ã‚Šè¿”ã™
for i in range(4 * NUM_LEDS):
  for j in range(NUM_LEDS):
    r = j * 100 // (NUM_LEDS - 1)
    b = 100 - j * 100 // (NUM_LEDS - 1)
    if j != i % NUM_LEDS:
      r >>= 3
      b >>= 3
    ar[j] = r << 16 | b

  # 1ãƒ¯ãƒ¼ãƒ‰ã¯32ãƒ“ãƒƒãƒˆã®ãŸã‚ã€32ãƒ“ãƒƒãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†ãŒã€@rp2.asm_pio ã§è‡ªå‹•ãƒ—ãƒ«ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¦ã€
  # 24ãƒ“ãƒƒãƒˆå‡¦ç†ã—ãŸã‚‰è‡ªå‹•çš„ã«ãƒ‡ãƒ¼ã‚¿ã‚’ TX FIFO ã‹ã‚‰å–ã‚Šå‡ºã—ã¦ã„ã‚‹ã€‚(autopull=True, pull_thresh=24)
  # ã¾ãŸã€ä¸Šä½ãƒ“ãƒƒãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šå‡ºã™ã®ã§ã€ä¸Šä½ 8 ãƒ“ãƒƒãƒˆãŒç©ºã„ã¦ã—ã¾ã†(out_shiftdir=rp2.PIO.SHIFT_LEFT)
  # ãã“ã§ã€put() ã§ TX FIFO ã«ãƒ—ãƒƒã‚·ãƒ¥æ™‚ã«ãƒ‡ãƒ¼ã‚¿ã‚’ 8 ãƒ“ãƒƒãƒˆã‚·ãƒ•ãƒˆã—ã¦ãŠãã€‚
  # xxxxxxxx 11111111 111111111 11111111 => 11111111 111111111 11111111 00000000
  sm.put(ar, 8)
  time.sleep_ms(50)

# ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
for i in range(24):
  for j in range(NUM_LEDS):
    ar[j] >>= 1
  sm.put(ar, 8)
  time.sleep_ms(50)
```

#### UART

- [PIOã§è‡ªä½œUARTé€šä¿¡](https://note.com/fjtech/n/n15e9a624df08)
- [ã‚ˆãåˆ†ã‹ã‚‹ï¼ ã‚·ãƒªã‚¢ãƒ«é€šä¿¡åŸºç¤è¬›åº§](https://emb.macnica.co.jp/articles/8191)
- [pio_uart_tx.py](https://github.com/micropython/micropython/blob/master/examples/rp2/pio_uart_tx.py)
- [pio_uart_rx.py](https://github.com/micropython/micropython/blob/master/examples/rp2/pio_uart_rx.py)
- [interface 2024/03](https://www.cqpub.co.jp/interface/download/2024/3/IF2403T2B1S.zip)

- ãƒã‚¤ãƒ³ãƒˆ
  - é€šå¸¸æ™‚ï¼ˆä½•ã‚‚ãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚‰ãªã„ idle ã®ã¨ãï¼‰ã¯ã€HIGH ã®çŠ¶æ…‹ã«ãªã£ã¦ã„ã‚‹ = idle high
  - ã‚¹ã‚¿ãƒ¼ãƒˆãƒ“ãƒƒãƒˆ(1bit) = 0 ã‚’ 1bit é€ä¿¡ãŒé–‹å§‹ã®åˆå›³
  - ã‚¹ãƒˆãƒƒãƒ—ãƒ“ãƒƒãƒˆ(1|2 bit) = 1 ã‚’ 1|2 bit é€ä¿¡ãŒçµ‚äº†ã®åˆå›³
    - 1 or 2 ã¯æœ€åˆã®è¨­å®šæ¬¡ç¬¬
  - ãƒ‡ãƒ¼ã‚¿ãƒ“ãƒƒãƒˆ(7|8bit)
    - 7 or 8 ã¯æœ€åˆã®è¨­å®šæ¬¡ç¬¬
    - ã‚¹ã‚¿ãƒ¼ãƒˆãƒ“ãƒƒãƒˆå¾Œã¯ã€baudrate ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã€LSB ã‹ã‚‰ 1bit ãšã¤é€ä¿¡ã™ã‚‹
  - baudrate ã¯ 1 ç§’é–“ã«é€ã‚‹ãƒ“ãƒƒãƒˆæ•°
    - PIO ã§ã¯ã€1bit ã®å‡¦ç†ã‚’ 8ã‚µã‚¤ã‚¯ãƒ«ã«ã™ã‚‹ãŸã‚ã«ã€å‘¨æ³¢æ•°ã¯ `baudrate * ãƒ‡ãƒ¼ã‚¿ãƒ“ãƒƒãƒˆæ•°` ã«ã™ã‚‹
  - ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã‚¿ã‚¤ãƒŸãƒ³ã‚°
    - 1ãƒ“ãƒƒãƒˆã‚’ 8ã‚µã‚¤ã‚¯ãƒ«ã«ã—ã¦ã„ã‚‹ãŸã‚ã€èª­ã¿è¾¼ã¿ã¯çœŸã‚“ä¸­ã® 4ã‚µã‚¤ã‚¯ãƒ«ç›®ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®å€¤ã‚’èª­ã¿è¾¼ã‚€
    - ã“ã®ãŸã‚ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿æ™‚ã®ã‚¦ã‚§ã‚¤ãƒˆã¯ 8+4=12 ã‚µã‚¤ã‚¯ãƒ«ã¨ãªã‚‹

  - ãƒ‘ãƒªãƒ†ã‚£
    - ã‚»ãƒƒãƒˆã™ã‚‹å ´åˆã¯ã€ãƒ‡ãƒ¼ã‚¿ã®å¾Œã«ç½®ã
    - å¶æ•°ãƒ‘ãƒªãƒ†ã‚£: ãƒ‡ãƒ¼ã‚¿ãƒ“ãƒƒãƒˆã«å«ã¾ã‚Œã‚‹ 1 ã®æ•°ã®åˆè¨ˆãŒã€ãƒ‘ãƒªãƒ†ã‚£ãƒ“ãƒƒãƒˆã‚’è¶³ã—ã¦å¶æ•°ã«ãªã‚‹ã‚ˆã†ã«ã™ã‚‹
      - ex) data: 1001 0010 => parity: 1, data: 1001 0110 => parity: 0
    - å¥‡æ•°ãƒ‘ãƒªãƒ†ã‚£: ãƒ‡ãƒ¼ã‚¿ãƒ“ãƒƒãƒˆã«å«ã¾ã‚Œã‚‹ 1 ã®æ•°ã®åˆè¨ˆãŒã€ãƒ‘ãƒªãƒ†ã‚£ãƒ“ãƒƒãƒˆã‚’è¶³ã—ã¦å¥‡æ•°ã«ãªã‚‹ã‚ˆã†ã«ã™ã‚‹
      - ex) data: 1001 0010 => parity: 0, data: 1001 0110 => parity: 1
    - ãƒ‘ãƒªãƒ†ã‚£ãªã—


```python:uart_tx.py
from machine import Pin, UART
from rp2 import PIO, StateMachine, asm_pio
import utime, time

UART_BAUDRATE = 9600
UART_DATABIT  = 8
CYCLE_PER_BIT = 8
PIO_TX_PIN = Pin(3, Pin.OUT)

# ãƒ»sideset, out ãƒ”ãƒ³ã¯å‡ºåŠ›ãƒ”ãƒ³ãªã®ã§ã€é€šå¸¸æ™‚ã¯ HIGH ãªã®ã§åˆæœŸçŠ¶æ…‹ã‚‚ HIGH ã«ã™ã‚‹
# ãƒ»LSB ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã™ã‚‹ã®ã§ã€å³ã‹ã‚‰ã‚·ãƒ•ãƒˆã™ã‚‹
# ãƒ»out() ã§ OSR ã‹ã‚‰ 8bit ã‚·ãƒ•ãƒˆã—ãŸã‚‰è‡ªå‹•çš„ã« TX FIFO ã‹ã‚‰èª­ã¿å‡ºã™
@asm_pio(sideset_init=PIO.OUT_HIGH, out_init=PIO.OUT_HIGH, out_shiftdir=PIO.SHIFT_RIGHT, fifo_join=PIO.JOIN_TX)
def uart_tx():
  CYCLE_PER_BIT = 8

  # 1ã‚µã‚¤ã‚¯ãƒ« ##################################################
  # TX FIFO ã‹ã‚‰ OSR ã«ãƒ—ãƒ«
  # ãƒ«ãƒ¼ãƒ—å‰ã® nop() ã‚’å«ã‚ã¦ 8ã‚µã‚¤ã‚¯ãƒ«ã«ãªã‚‹ã€‚
  pull()
  #############################################################

  # 8ã‚µã‚¤ã‚¯ãƒ« ##################################################
  # ã‚¹ã‚¿ãƒ¼ãƒˆãƒ“ãƒƒãƒˆ(1bit ã® side(0)=Low)
  # set ã® 7 ã¯ãƒ‡ãƒ¼ã‚¿ãƒ“ãƒƒãƒˆã® 8ãƒ“ãƒƒãƒˆåˆ†ã‚’ãƒ«ãƒ¼ãƒ—ã™ã‚‹ãŸã‚ã®å€¤
  set(x, 7)     .side(0)  [CYCLE_PER_BIT-1] # 1 + 7 = 8ã‚µã‚¤ã‚¯ãƒ«
  #############################################################
  label("bitloop")
  # 8ã‚µã‚¤ã‚¯ãƒ« ##################################################
  # ãƒ‡ãƒ¼ã‚¿ãƒ“ãƒƒãƒˆ(LSBã‹ã‚‰ï¼‘ãƒ“ãƒƒãƒˆãšã¤ï¼—ãƒ“ãƒƒãƒˆåˆ†)
  # 7 + 1 = 8ã‚µã‚¤ã‚¯ãƒ«ã§ãƒ«ãƒ¼ãƒ—
  out(pins, 1)
  jmp(x_dec, "bitloop")   [CYCLE_PER_BIT-2] # 1 + 6 = 7ã‚µã‚¤ã‚¯ãƒ«
  #############################################################

  # 7ã‚µã‚¤ã‚¯ãƒ« ##################################################
  # ã‚¹ãƒˆãƒƒãƒ—ãƒ“ãƒƒãƒˆ(1bit ã® High=side(1))
  # ãƒ«ãƒ¼ãƒ—ã—ã¦ pull() ã‚’å«ã‚ã¦ 8ã‚µã‚¤ã‚¯ãƒ«ã«ãªã‚‹ã€‚
  nop()         .side(1)  [CYCLE_PER_BIT-2] # 1 + 6 = 7ã‚µã‚¤ã‚¯ãƒ«ã€‚
  #############################################################

# PIO å‡¦ç†é–‹å§‹
sm = StateMachine(0, uart_tx, freq=UART_BAUDRATE*CYCLE_PER_BIT, sideset_base=PIO_TX_PIN, out_base=PIO_TX_PIN)
sm.active(1)

uart0 = UART(0, baudrate=9600, tx=Pin(0), rx=Pin(1))

# ãƒ‡ãƒ¼ã‚¿é€ä¿¡
for c in "hello world!\n":
  sm.put(ord(c))
  utime.sleep(0.1)

# UART å—ä¿¡å‡¦ç†
recv = b""
start = time.ticks_ms()
while time.ticks_diff(time.ticks_ms(), start) < 3000:   # 3ç§’é–“ã ã‘ãƒ«ãƒ¼ãƒ—
  if uart0.any():
    recv += uart0.read(1)

print("UART0 Received:", recv.decode())
```

```python:uart_rx.py
from machine import Pin, UART
from rp2 import PIO, StateMachine, asm_pio
import utime, time

UART_BAUDRATE = 9600
UART_DATABIT  = 8
CYCLE_PER_BIT = 8
PIO_RX_PIN = Pin(4, Pin.IN, Pin.PULL_UP)

@asm_pio(in_shiftdir=PIO.SHIFT_RIGHT, fifo_join=PIO.JOIN_RX, autopush=True, push_thresh=UART_DATABIT)
def uart_rx():
  # ã‚¹ãƒˆãƒƒãƒ—ãƒ“ãƒƒãƒˆã‚’å¾…ã¤
  # wait(1, pin, 0)

  # 12ã‚µã‚¤ã‚¯ãƒ« ####################################################
  # ã‚¹ã‚¿ãƒ¼ãƒˆãƒ“ãƒƒãƒˆ8bit + 4bit(ãƒ‡ãƒ¼ã‚¿ã®çœŸã‚“ä¸­ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’èª­ã¿è¾¼ã‚€ãŸã‚)

  # ã‚¹ã‚¿ãƒ¼ãƒˆãƒ“ãƒƒãƒˆã‚’å¾…ã¤
  wait(0, pin, 0)                 # 1ã‚µã‚¤ã‚¯ãƒ«
  # ãƒ«ãƒ¼ãƒ—ã‚«ã‚¦ãƒ³ã‚¿ã‚’ã‚»ãƒƒãƒˆã—ã¦ã€æœ€åˆã®ãƒ‡ãƒ¼ã‚¿ãƒ“ãƒƒãƒˆã¾ã§å¾…ã¤ã€‚
  set(x, 7)                 [10]  # 1 + 10 = 11ã‚µã‚¤ã‚¯ãƒ«
  ################################################################
  label("bitloop")
  # 8ã‚µã‚¤ã‚¯ãƒ« #####################################################
  # ãƒ‡ãƒ¼ã‚¿ã‚’ LSB ã‹ã‚‰ 1bitãšã¤ ISR ã«èª­ã¿è¾¼ã¿
  # ISR ã¯ 32bitã§ã€SHIFT_RIGHT ã‚’æŒ‡å®šã—ã¦ã„ã‚‹ã®ã§ã€ä»¥ä¸‹ã®ãƒ‡ãƒ¼ã‚¿ã«ãªã‚‹
  # 01010101 -------- -------- --------
  in_(pins, 1)                    # 1ã‚µã‚¤ã‚¯ãƒ«
  jmp(x_dec, "bitloop")     [5]   # 1 + 5 = 6ã‚µã‚¤ã‚¯ãƒ«
  # 24bit åˆ†ã‚ºãƒ©ã™
  # -------- -------- -------- 01010101
  in_(null, 24)
  ################################################################

  # 8ã‚µã‚¤ã‚¯ãƒ« #####################################################
  # GPIO ã«å‡ºåŠ›
  push()                          # 1ã‚µã‚¤ã‚¯ãƒ«
  # ã‚¹ãƒˆãƒƒãƒ—ãƒ“ãƒƒãƒˆã‚’å¾…ã¤
  wait(1, pin, 0)           [6]   # 1 + 6 = 7ã‚µã‚¤ã‚¯ãƒ«
  ################################################################

# PIO å‡¦ç†é–‹å§‹
sm = StateMachine(0, uart_rx, freq=UART_BAUDRATE*CYCLE_PER_BIT, in_base=PIO_RX_PIN)
sm.active(1)

uart0 = UART(0, baudrate=9600, tx=Pin(0), rx=Pin(1))

uart0.write("Hello World!")

start = time.ticks_ms()
while time.ticks_diff(time.ticks_ms(), start) < 3000:   # 3ç§’é–“ã ã‘ãƒ«ãƒ¼ãƒ—
  if sm.rx_fifo():
    data = sm.get()
    print(data.decode())
```

### æ§‹æˆ

[Raspberry Pi Pico/W ã®PIOã‚’èª¿æŸ»ã™ã‚‹ãï¼](https://karakuri-musha.com/inside-technology/arduino-raspberrypi-picow-tips-piostartup01/)
[ãƒ©ã‚ºãƒ”ã‚³ PIO ï½è§£èª¬ç·¨ï½](https://moons.link/pico/post-498/#outline__5_7)

- PIO: x2 å€‹
  - State Machine: x4
    - OSR(Output Shift Resister): TX FIFO ã‹ã‚‰ã‚·ãƒ•ãƒˆã™ã‚‹
    - ISR(Input Shift Resister) : RX FIFO ã¸ã‚·ãƒ•ãƒˆã™ã‚‹
    - PC(Program Counter)       : ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚«ã‚¦ãƒ³ã‚¿
    - ScratchX(Scratch Resister): 32bit ãƒ¬ã‚¸ã‚¹ã‚¿
    - ScratchY(Scratch Resister): 32bit ãƒ¬ã‚¸ã‚¹ã‚¿
    - Clock Div                 : ã‚¯ãƒ­ãƒƒã‚¯åˆ†å‘¨å™¨
    - Control Logic             : å®Ÿè¡Œåˆ¶å¾¡
  - FIFO: Max32bit x8
  - Instruction Memory: 16bit x 32å‘½ä»¤
  - I/O Mapping: PIO ã¨ ç‰©ç†çš„ãªIOãƒ”ãƒ³ã®å¯¾å¿œä»˜ã‘
    - out pins
    - in pins
    - side-set pins
  - IRQ: x2

### ç”¨èª

- ãƒ¯ãƒ¼ãƒ‰
  CPU ãŒä¸€åº¦ã«å‡¦ç†ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿ã®å¹…ã€‚1ãƒ¯ãƒ¼ãƒ‰ = 32ãƒ“ãƒƒãƒˆãªã©

- MSB(Most Significant Bit) / LSB(Least Significant Bit)
  MSB = æœ€ä¸Šä½ãƒ“ãƒƒãƒˆ, LSB = æœ€ä¸‹ä½ãƒ“ãƒƒãƒˆ

- é…å»¶(Delay)
  Delay ã¨ side-set ã¯ã€`å‘½ä»¤ã‚»ãƒƒãƒˆ` å†…ã§ã€5ãƒ“ãƒƒãƒˆ(2^5 = 32) æŒ‡å®šã§ãã‚‹ã€‚
  side-set ã‚’ä½¿ç”¨ã—ãªã„å ´åˆã«ã€æœ€å¤§ 31 ã‚µã‚¤ã‚¯ãƒ«é…å»¶å¯èƒ½ã€‚

- ã‚µã‚¤ãƒ‰ã‚»ãƒƒãƒˆ(side-set)
  å‘½ä»¤ã®å®Ÿè¡Œæ™‚ã«ã€å‘½ä»¤ã¨åŒæ™‚ã«
  `side-set` ã¨ã—ã¦æŒ‡å®šã—ãŸãƒ”ãƒ³ã®çŠ¶æ…‹(High | Low)ã‚’æŒ‡å®šã§ãã‚‹ã€‚

- ãƒ‡ãƒ¼ã‚¿ã®æµã‚Œ
  - ãƒ”ãƒ³ã‹ã‚‰å–å¾—
    1. in()  : Pin -> ISR
    2. push(): ISR -> RX FIFO
    3. RX FIFO ã¯ CPU ã§å‡¦ç†ã•ã‚Œã‚‹

  - ãƒ”ãƒ³ã¸åæ˜ 
    1. CPU ã‹ã‚‰ TX FIFO ã«æ ¼ç´
    2. pull(): TX FIFO -> OSR
    3. out() : OSR -> Pin

- ãƒ•ãƒ¬ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡
  ï¼‘ç”»é¢åˆ†ã®è¡¨ç¤ºå†…å®¹ã‚’ä¸¸ã”ã¨è¨˜æ†¶ã—ã¦ãŠãã“ã¨ãŒã§ãã‚‹ãƒ¡ãƒ¢ãƒªé ˜åŸŸã¾ãŸã¯ãƒ¡ãƒ¢ãƒªè£…ç½®ã®ã“ã¨
  ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã¯ã€ã¾ãšãƒ•ãƒ¬ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã®å†…å®¹ã‚’æ›¸ãæ›ãˆã‚‹ã€‚
  ãƒ•ãƒ¬ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã®å†…å®¹ãŒä¸€å®šã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ã«è¡¨ç¤ºã•ã‚Œã‚‹ã€‚
  ã“ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§æç”»é€”ä¸­ã®ä¸­é€”åŠç«¯ãªçŠ¶æ…‹ã‚’è¦‹ã›ãªãã¦ã‚ˆã„ã‚ˆã†ã«ã—ã¦ã„ã‚‹ã€‚
  ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒª(RAM) ã®ä¸€éƒ¨ã‚’å°‚ç”¨é ˜åŸŸã¨ã—ã¦ç¢ºä¿ã—ã¦ãƒ•ãƒ¬ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã¨ã—ãŸã‚Šã€å°‚ç”¨ã®ãƒ¡ãƒ¢ãƒªè£…ç½®ã‚’ä½¿ã£ãŸã‚Šã™ã‚‹ã€‚

  - [framebuf](https://micropython-docs-ja.readthedocs.io/ja/latest/library/framebuf.html)

    - RGB565
      RGB ã‚’ 16 ãƒ“ãƒƒãƒˆã§æŒ‡å®šã™ã‚‹ï¼ˆR=5bit, G=6bit, B=5bitï¼‰
      ã¤ã¾ã‚Š R ã¨ B ã¯ã€32æ®µéšã§è¡¨ç¾ã€G ã¯ 64æ®µéšã§è¡¨ç¾ã™ã‚‹ã€‚
      R,B: floor(xbit * 31 / 255) G: floor(xbit * 63 / 255)
      ex) `01111 111111 00011` => R=15, G=64, B=3

      ```python:framebuf_sample.py
      import framebuf

      width  = 100
      height = 10
      # RGB565 ã‚’ä½¿ç”¨ã™ã‚‹ã®ã§ã€ç‚¹ï¼‘ã¤ã« 16ãƒ“ãƒƒãƒˆ = 2ãƒã‚¤ãƒˆä½¿ã†
      let buf = bytearray(width * height * 2)
      fbuf = framebuf.FrameBuffer(buf, width, height, framebuf.RGB565)
      fbug.fill(0)
      ```

  - [NeoPixel](https://micropython-docs-ja.readthedocs.io/ja/latest/library/neopixel.html)

    ```python:neopixel_sample.py
    import neopixel
    from machine import Pin

    COLORS = {
      "off": (0,  0, 0),
      "red": (10, 0, 0),
    }

    pin = Pin(16, Pin.OUT)
    led_num = 32
    np = neopixel.NeoPixel(pin, led_num)
    np.fill(COLORS["off"])
    for i in range(led_num):
      # ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ LED ã‚’æŒ‡å®šã—ã€RGBå€¤ã¯ã‚¿ãƒ—ãƒ«ã§æŒ‡å®š
      np[i] = (i * 8, 0, 0)

    np.write()
    ```

  - [bytearray](https://docs.python.org/ja/3/library/functions.html#func-bytearray)
    å€¤ãŒ 0ï½255 ã®æ•´æ•°ã§ã‚ã‚‹å¤‰æ›´å¯èƒ½ãªé…åˆ—

